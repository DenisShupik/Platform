// This file is auto-generated by @hey-api/openapi-ts

export type CategoryDto = {
    categoryId: CategoryId;
    forumId: ForumId;
    title: CategoryTitle;
    createdBy: UserId;
    createdAt: Date;
};

export type CategoryId = string;

export type CategoryNotFoundError = {
    readonly $type: string;
    categoryId: CategoryId;
};

export type CategoryTitle = string;

/**
 * Типы каналов доставки уведомлений
 *
 * 0 = Internal (Внутренний канал)
 *
 * 1 = Email (Электронная почта)
 */
export enum ChannelType {
    /**
     * Internal
     * Внутренний канал
     */
    INTERNAL = 0,
    /**
     * Email
     * Электронная почта
     */
    EMAIL = 1
}

export type CreateCategoryRequestBody = {
    forumId: ForumId;
    title: CategoryTitle;
};

export type CreateForumRequestBody = {
    title: ForumTitle;
};

export type CreatePostRequestBody = {
    content: PostContent;
};

export type CreateThreadRequestBody = {
    categoryId: CategoryId;
    title: ThreadTitle;
};

export type CreateThreadSubscriptionRequestBody = {
    /**
     * Каналы, по которым пользователь подписан на уведомления по данной теме
     */
    channels: Array<ChannelType>;
};

export type DuplicateThreadSubscriptionError = {
    readonly $type: string;
    userId: UserId;
    threadId: ThreadId;
};

/**
 *
 *
 * 0 = Category (Форум содержит разделы)
 *
 * 1 = Thread (Форум содержит темы)
 *
 * 2 = Post (Форум содержит сообщения)
 */
export enum ForumContainsFilter {
    /**
     * Category
     * Форум содержит разделы
     */
    CATEGORY = 0,
    /**
     * Thread
     * Форум содержит темы
     */
    THREAD = 1,
    /**
     * Post
     * Форум содержит сообщения
     */
    POST = 2
}

export type ForumDto = {
    forumId: ForumId;
    title: ForumTitle;
    createdBy: UserId;
    createdAt: Date;
};

export type ForumId = string;

export type ForumNotFoundError = {
    readonly $type: string;
    forumId: ForumId;
};

export type ForumTitle = string;

/**
 *
 *
 * activity (Sort by Activity ascending)
 *
 * -activity (Sort by Activity descending)
 */
export enum GetCategoryThreadsQuerySortEnum {
    /**
     * ActivityAsc
     * Sort by Activity ascending
     */
    ACTIVITY_ASC = 'activity',
    /**
     * ActivityDesc
     * Sort by Activity descending
     */
    ACTIVITY_DESC = '-activity'
}

/**
 *
 *
 * 0 = Activity
 */
export enum GetCategoryThreadsQuerySortType {
    /**
     * Activity
     */
    ACTIVITY = 0
}

/**
 *
 *
 * latestpost (Sort by LatestPost ascending)
 *
 * -latestpost (Sort by LatestPost descending)
 */
export enum GetForumsQuerySortEnum {
    /**
     * LatestPostAsc
     * Sort by LatestPost ascending
     */
    LATEST_POST_ASC = 'latestpost',
    /**
     * LatestPostDesc
     * Sort by LatestPost descending
     */
    LATEST_POST_DESC = '-latestpost'
}

/**
 *
 *
 * 0 = LatestPost
 */
export enum GetForumsQuerySortType {
    /**
     * LatestPost
     */
    LATEST_POST = 0
}

/**
 *
 *
 * occurredat (Sort by OccurredAt ascending)
 *
 * deliveredat (Sort by DeliveredAt ascending)
 *
 * -occurredat (Sort by OccurredAt descending)
 *
 * -deliveredat (Sort by DeliveredAt descending)
 */
export enum GetInternalNotificationQuerySortEnum {
    /**
     * OccurredAtAsc
     * Sort by OccurredAt ascending
     */
    OCCURRED_AT_ASC = 'occurredat',
    /**
     * DeliveredAtAsc
     * Sort by DeliveredAt ascending
     */
    DELIVERED_AT_ASC = 'deliveredat',
    /**
     * OccurredAtDesc
     * Sort by OccurredAt descending
     */
    OCCURRED_AT_DESC = '-occurredat',
    /**
     * DeliveredAtDesc
     * Sort by DeliveredAt descending
     */
    DELIVERED_AT_DESC = '-deliveredat'
}

/**
 *
 *
 * 0 = OccurredAt
 *
 * 1 = DeliveredAt
 */
export enum GetInternalNotificationQuerySortType {
    /**
     * OccurredAt
     */
    OCCURRED_AT = 0,
    /**
     * DeliveredAt
     */
    DELIVERED_AT = 1
}

export type GetThreadSubscriptionStatusQueryResult = {
    /**
     * Подписан ли пользователь на тему
     */
    isSubscribed: boolean;
};

export type InternalNotificationDto = {
    payload: PostAddedNotifiableEventPayload | PostUpdatedNotifiableEventPayload;
    occurredAt: Date;
    notifiableEventId: NotifiableEventId;
    deliveredAt?: Date | null;
};

export type InternalNotificationsPagedDto = {
    notifications: Array<InternalNotificationDto>;
    threads: {
        [key: string]: ThreadTitle;
    };
    users: {
        [key: string]: Username;
    };
    /**
     * Общее количество уведомлений с учетом фильтрации
     */
    totalCount: bigint;
};

export type NonPostAuthorError = {
    readonly $type: string;
    threadId: ThreadId;
    postId: PostId;
};

export type NonThreadOwnerError = {
    readonly $type: string;
    threadId: ThreadId;
};

export type NotOwnerError = {
    readonly $type: string;
};

export type NotifiableEventId = string;

export type NotifiableEventPayload = {
    $type: string;
};

export type NotificationNotFoundError = {
    readonly $type: string;
    userId: UserId;
    notifiableEventId: NotifiableEventId;
    /**
     * Типы каналов доставки уведомлений
     *
     * 0 = Internal (Внутренний канал)
     *
     * 1 = Email (Электронная почта)
     */
    channel: ChannelType;
};

export type PostAddedNotifiableEventPayload = NotifiableEventPayload & {
    $type: 'PostAddedNotifiableEventPayload';
} & {
    threadId: ThreadId;
    postId: PostId;
    createdBy: UserId;
};

export type PostContent = string;

export type PostDto = {
    threadId: ThreadId;
    postId: PostId;
    content: PostContent;
    createdBy: UserId;
    createdAt: Date;
    updatedBy: UserId;
    updatedAt: Date;
    rowVersion: number;
};

export type PostId = bigint;

export type PostNotFoundError = {
    readonly $type: string;
    threadId: ThreadId;
    postId: PostId;
};

export type PostStaleError = {
    readonly $type: string;
    threadId: ThreadId;
    postId: PostId;
    rowVersion: number;
};

export type PostUpdatedNotifiableEventPayload = NotifiableEventPayload & {
    $type: 'PostUpdatedNotifiableEventPayload';
} & {
    threadId: ThreadId;
    postId: PostId;
    updatedBy: UserId;
};

/**
 *
 *
 * 0 = Ascending
 *
 * 1 = Descending
 */
export enum SortOrderType {
    /**
     * Ascending
     */
    ASCENDING = 0,
    /**
     * Descending
     */
    DESCENDING = 1
}

export type ThreadDto = {
    threadId: ThreadId;
    categoryId: CategoryId;
    title: ThreadTitle;
    createdBy: UserId;
    createdAt: Date;
    nextPostId: PostId;
    /**
     * Состояние темы
     *
     * 0 = Draft (Тема еще подготавливается автором)
     *
     * 1 = Published (Тема опубликована и доступна пользователям)
     */
    status: ThreadStatus;
};

export type ThreadId = string;

export type ThreadNotFoundError = {
    readonly $type: string;
    threadId: ThreadId;
};

/**
 * Состояние темы
 *
 * 0 = Draft (Тема еще подготавливается автором)
 *
 * 1 = Published (Тема опубликована и доступна пользователям)
 */
export enum ThreadStatus {
    /**
     * Draft
     * Тема еще подготавливается автором
     */
    DRAFT = 0,
    /**
     * Published
     * Тема опубликована и доступна пользователям
     */
    PUBLISHED = 1
}

export type ThreadSubscriptionNotFoundError = {
    readonly $type: string;
    userId: UserId;
    threadId: ThreadId;
};

export type ThreadTitle = string;

export type UpdatePostRequestBody = {
    content: PostContent;
    rowVersion: number;
};

export type UserDto = {
    userId: UserId;
    username: Username;
    email: string;
    enabled: boolean;
    createdAt: Date;
};

export type UserId = string;

export type UserNotFoundError = {
    readonly $type: string;
    userId: UserId;
};

export type Username = string;

export type GetCategoriesData = {
    body?: never;
    path?: never;
    query?: {
        offset?: number;
        limit?: number;
        forumId?: ForumId;
        title?: CategoryTitle;
    };
    url: '/api/categories';
};

export type GetCategoriesResponses = {
    /**
     * OK
     */
    200: Array<CategoryDto>;
};

export type GetCategoriesResponse = GetCategoriesResponses[keyof GetCategoriesResponses];

export type CreateCategoryData = {
    body: CreateCategoryRequestBody;
    path?: never;
    query?: never;
    url: '/api/categories';
};

export type CreateCategoryErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Not Found
     */
    404: ForumNotFoundError;
};

export type CreateCategoryError = CreateCategoryErrors[keyof CreateCategoryErrors];

export type CreateCategoryResponses = {
    /**
     * OK
     */
    200: CategoryId;
};

export type CreateCategoryResponse = CreateCategoryResponses[keyof CreateCategoryResponses];

export type GetCategoryData = {
    body?: never;
    path: {
        categoryId: CategoryId;
    };
    query?: never;
    url: '/api/categories/{categoryId}';
};

export type GetCategoryErrors = {
    /**
     * Not Found
     */
    404: CategoryNotFoundError;
};

export type GetCategoryError = GetCategoryErrors[keyof GetCategoryErrors];

export type GetCategoryResponses = {
    /**
     * OK
     */
    200: CategoryDto;
};

export type GetCategoryResponse = GetCategoryResponses[keyof GetCategoryResponses];

export type GetCategoriesPostsCountData = {
    body?: never;
    path: {
        categoryIds: Array<CategoryId>;
    };
    query?: never;
    url: '/api/categories/{categoryIds}/posts/count';
};

export type GetCategoriesPostsCountResponses = {
    /**
     * OK
     */
    200: {
        [key: string]: bigint;
    };
};

export type GetCategoriesPostsCountResponse = GetCategoriesPostsCountResponses[keyof GetCategoriesPostsCountResponses];

export type GetCategoriesPostsLatestData = {
    body?: never;
    path: {
        categoryIds: Array<CategoryId>;
    };
    query?: never;
    url: '/api/categories/{categoryIds}/posts/latest';
};

export type GetCategoriesPostsLatestResponses = {
    /**
     * OK
     */
    200: {
        [key: string]: PostDto;
    };
};

export type GetCategoriesPostsLatestResponse = GetCategoriesPostsLatestResponses[keyof GetCategoriesPostsLatestResponses];

export type GetCategoriesThreadsCountData = {
    body?: never;
    path: {
        categoryIds: Array<CategoryId>;
    };
    query?: {
        includeDraft?: boolean;
    };
    url: '/api/categories/{categoryIds}/threads/count';
};

export type GetCategoriesThreadsCountResponses = {
    /**
     * OK
     */
    200: {
        [key: string]: bigint;
    };
};

export type GetCategoriesThreadsCountResponse = GetCategoriesThreadsCountResponses[keyof GetCategoriesThreadsCountResponses];

export type GetCategoryThreadsData = {
    body?: never;
    path: {
        categoryId: CategoryId;
    };
    query?: {
        offset?: number;
        limit?: number;
        /**
         *
         *
         * activity (Sort by Activity ascending)
         *
         * -activity (Sort by Activity descending)
         */
        sort?: GetCategoryThreadsQuerySortEnum;
        includeDraft?: boolean;
    };
    url: '/api/categories/{categoryId}/threads';
};

export type GetCategoryThreadsErrors = {
    /**
     * Not Found
     */
    404: unknown;
};

export type GetCategoryThreadsResponses = {
    /**
     * OK
     */
    200: Array<ThreadDto>;
};

export type GetCategoryThreadsResponse = GetCategoryThreadsResponses[keyof GetCategoryThreadsResponses];

export type GetForumsCountData = {
    body?: never;
    path?: never;
    query?: {
        createdBy?: UserId;
        /**
         *
         *
         * 0 = Category (Форум содержит разделы)
         *
         * 1 = Thread (Форум содержит темы)
         *
         * 2 = Post (Форум содержит сообщения)
         */
        contains?: ForumContainsFilter;
    };
    url: '/api/forums/count';
};

export type GetForumsCountResponses = {
    /**
     * OK
     */
    200: bigint;
};

export type GetForumsCountResponse = GetForumsCountResponses[keyof GetForumsCountResponses];

export type GetForumsData = {
    body?: never;
    path?: never;
    query?: {
        offset?: number;
        limit?: number;
        /**
         *
         *
         * latestpost (Sort by LatestPost ascending)
         *
         * -latestpost (Sort by LatestPost descending)
         */
        sort?: GetForumsQuerySortEnum;
        title?: ForumTitle;
        createdBy?: UserId;
        /**
         *
         *
         * 0 = Category (Форум содержит разделы)
         *
         * 1 = Thread (Форум содержит темы)
         *
         * 2 = Post (Форум содержит сообщения)
         */
        contains?: ForumContainsFilter;
    };
    url: '/api/forums';
};

export type GetForumsResponses = {
    /**
     * OK
     */
    200: Array<ForumDto>;
};

export type GetForumsResponse = GetForumsResponses[keyof GetForumsResponses];

export type CreateForumData = {
    body: CreateForumRequestBody;
    path?: never;
    query?: never;
    url: '/api/forums';
};

export type CreateForumErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type CreateForumResponses = {
    /**
     * OK
     */
    200: ForumId;
};

export type CreateForumResponse = CreateForumResponses[keyof CreateForumResponses];

export type GetForumData = {
    body?: never;
    path: {
        forumId: ForumId;
    };
    query?: never;
    url: '/api/forums/{forumId}';
};

export type GetForumErrors = {
    /**
     * Not Found
     */
    404: ForumNotFoundError;
};

export type GetForumError = GetForumErrors[keyof GetForumErrors];

export type GetForumResponses = {
    /**
     * OK
     */
    200: ForumDto;
};

export type GetForumResponse = GetForumResponses[keyof GetForumResponses];

export type GetForumsCategoriesCountData = {
    body?: never;
    path: {
        forumIds: Array<ForumId>;
    };
    query?: never;
    url: '/api/forums/{forumIds}/categories/count';
};

export type GetForumsCategoriesCountResponses = {
    /**
     * OK
     */
    200: {
        [key: string]: bigint;
    };
};

export type GetForumsCategoriesCountResponse = GetForumsCategoriesCountResponses[keyof GetForumsCategoriesCountResponses];

export type GetForumsCategoriesLatestData = {
    body?: never;
    path: {
        forumIds: Array<ForumId>;
    };
    query?: {
        count?: number;
    };
    url: '/api/forums/{forumIds}/categories/latest';
};

export type GetForumsCategoriesLatestResponses = {
    /**
     * OK
     */
    200: {
        [key: string]: Array<CategoryDto>;
    };
};

export type GetForumsCategoriesLatestResponse = GetForumsCategoriesLatestResponses[keyof GetForumsCategoriesLatestResponses];

export type GetPostsData = {
    body?: never;
    path?: never;
    query?: {
        offset?: number;
        limit?: number;
        threadId?: ThreadId;
    };
    url: '/api/posts';
};

export type GetPostsResponses = {
    /**
     * OK
     */
    200: Array<PostDto>;
};

export type GetPostsResponse = GetPostsResponses[keyof GetPostsResponses];

export type GetThreadsPagedData = {
    body?: never;
    path?: never;
    query?: {
        offset?: number;
        limit?: number;
        createdBy?: UserId;
        /**
         *
         *
         * 0 = Draft (Тема еще подготавливается автором)
         *
         * 1 = Published (Тема опубликована и доступна пользователям)
         */
        status?: ThreadStatus;
    };
    url: '/api/threads';
};

export type GetThreadsPagedErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: NotOwnerError;
};

export type GetThreadsPagedError = GetThreadsPagedErrors[keyof GetThreadsPagedErrors];

export type GetThreadsPagedResponses = {
    /**
     * OK
     */
    200: Array<ThreadDto>;
};

export type GetThreadsPagedResponse = GetThreadsPagedResponses[keyof GetThreadsPagedResponses];

export type CreateThreadData = {
    body: CreateThreadRequestBody;
    path?: never;
    query?: never;
    url: '/api/threads';
};

export type CreateThreadErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Not Found
     */
    404: CategoryNotFoundError;
};

export type CreateThreadError = CreateThreadErrors[keyof CreateThreadErrors];

export type CreateThreadResponses = {
    /**
     * OK
     */
    200: ThreadId;
};

export type CreateThreadResponse = CreateThreadResponses[keyof CreateThreadResponses];

export type GetThreadsCountData = {
    body?: never;
    path?: never;
    query?: {
        createdBy?: UserId;
        /**
         *
         *
         * 0 = Draft (Тема еще подготавливается автором)
         *
         * 1 = Published (Тема опубликована и доступна пользователям)
         */
        status?: ThreadStatus;
    };
    url: '/api/threads/count';
};

export type GetThreadsCountErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: NotOwnerError;
};

export type GetThreadsCountError = GetThreadsCountErrors[keyof GetThreadsCountErrors];

export type GetThreadsCountResponses = {
    /**
     * OK
     */
    200: bigint;
};

export type GetThreadsCountResponse = GetThreadsCountResponses[keyof GetThreadsCountResponses];

export type GetThreadData = {
    body?: never;
    path: {
        threadId: ThreadId;
    };
    query?: never;
    url: '/api/threads/{threadId}';
};

export type GetThreadErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: NonThreadOwnerError;
    /**
     * Not Found
     */
    404: ThreadNotFoundError;
};

export type GetThreadError = GetThreadErrors[keyof GetThreadErrors];

export type GetThreadResponses = {
    /**
     * OK
     */
    200: ThreadDto;
};

export type GetThreadResponse = GetThreadResponses[keyof GetThreadResponses];

export type GetThreadsPostsCountData = {
    body?: never;
    path: {
        threadIds: Array<ThreadId>;
    };
    query?: never;
    url: '/api/threads/{threadIds}/posts/count';
};

export type GetThreadsPostsCountResponses = {
    /**
     * OK
     */
    200: {
        [key: string]: bigint;
    };
};

export type GetThreadsPostsCountResponse = GetThreadsPostsCountResponses[keyof GetThreadsPostsCountResponses];

export type GetThreadsPostsLatestData = {
    body?: never;
    path: {
        threadIds: Array<ThreadId>;
    };
    query?: never;
    url: '/api/threads/{threadIds}/posts/latest';
};

export type GetThreadsPostsLatestResponses = {
    /**
     * OK
     */
    200: {
        [key: string]: PostDto;
    };
};

export type GetThreadsPostsLatestResponse = GetThreadsPostsLatestResponses[keyof GetThreadsPostsLatestResponses];

export type GetPostOrderData = {
    body?: never;
    path: {
        threadId: ThreadId;
        postId: PostId;
    };
    query?: never;
    url: '/api/threads/{threadId}/posts/{postId}/order';
};

export type GetPostOrderErrors = {
    /**
     * Not Found
     */
    404: PostNotFoundError;
};

export type GetPostOrderError = GetPostOrderErrors[keyof GetPostOrderErrors];

export type GetPostOrderResponses = {
    /**
     * OK
     */
    200: bigint;
};

export type GetPostOrderResponse = GetPostOrderResponses[keyof GetPostOrderResponses];

export type CreatePostData = {
    body: CreatePostRequestBody;
    path: {
        threadId: ThreadId;
    };
    query?: never;
    url: '/api/threads/{threadId}/posts';
};

export type CreatePostErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: NonThreadOwnerError;
    /**
     * Not Found
     */
    404: ThreadNotFoundError;
};

export type CreatePostError = CreatePostErrors[keyof CreatePostErrors];

export type CreatePostResponses = {
    /**
     * OK
     */
    200: PostId;
};

export type CreatePostResponse = CreatePostResponses[keyof CreatePostResponses];

export type UpdatePostData = {
    body: UpdatePostRequestBody;
    path: {
        threadId: ThreadId;
        postId: PostId;
    };
    query?: never;
    url: '/api/threads/{threadId}/posts/{postId}';
};

export type UpdatePostErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: NonPostAuthorError;
    /**
     * Not Found
     */
    404: PostNotFoundError;
    /**
     * Conflict
     */
    409: PostStaleError;
};

export type UpdatePostError = UpdatePostErrors[keyof UpdatePostErrors];

export type UpdatePostResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type DeleteAvatarData = {
    body?: never;
    path?: never;
    query?: never;
    url: '/api/avatars';
};

export type DeleteAvatarErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type DeleteAvatarResponses = {
    /**
     * OK
     */
    200: unknown;
};

export type UploadAvatarData = {
    body?: {
        file: Blob | File;
    };
    path?: never;
    query?: never;
    url: '/api/avatars';
};

export type UploadAvatarErrors = {
    /**
     * Bad Request
     */
    400: string;
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Internal Server Error
     */
    500: unknown;
};

export type UploadAvatarError = UploadAvatarErrors[keyof UploadAvatarErrors];

export type UploadAvatarResponses = {
    /**
     * No Content
     */
    204: void;
};

export type UploadAvatarResponse = UploadAvatarResponses[keyof UploadAvatarResponses];

export type GetInternalNotificationCountData = {
    body?: never;
    path?: never;
    query?: {
        isDelivered?: boolean;
    };
    url: '/api/me/notifications/count';
};

export type GetInternalNotificationCountErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetInternalNotificationCountResponses = {
    /**
     * OK
     */
    200: number;
};

export type GetInternalNotificationCountResponse = GetInternalNotificationCountResponses[keyof GetInternalNotificationCountResponses];

export type GetInternalNotificationsPagedData = {
    body?: never;
    path?: never;
    query?: {
        offset?: number;
        limit?: number;
        sort?: Array<GetInternalNotificationQuerySortEnum>;
        isDelivered?: boolean;
    };
    url: '/api/me/notifications';
};

export type GetInternalNotificationsPagedErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetInternalNotificationsPagedResponses = {
    /**
     * OK
     */
    200: InternalNotificationsPagedDto;
};

export type GetInternalNotificationsPagedResponse = GetInternalNotificationsPagedResponses[keyof GetInternalNotificationsPagedResponses];

export type MarkInternalNotificationAsReadData = {
    body?: never;
    path: {
        notifiableEventId: NotifiableEventId;
    };
    query?: never;
    url: '/api/me/notifications/{notifiableEventId}/mark-read';
};

export type MarkInternalNotificationAsReadErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Not Found
     */
    404: NotificationNotFoundError;
};

export type MarkInternalNotificationAsReadError = MarkInternalNotificationAsReadErrors[keyof MarkInternalNotificationAsReadErrors];

export type MarkInternalNotificationAsReadResponses = {
    /**
     * No Content
     */
    204: void;
};

export type MarkInternalNotificationAsReadResponse = MarkInternalNotificationAsReadResponses[keyof MarkInternalNotificationAsReadResponses];

export type DeleteInternalNotificationData = {
    body?: never;
    path: {
        notifiableEventId: NotifiableEventId;
    };
    query?: never;
    url: '/api/me/notifications/{notifiableEventId}';
};

export type DeleteInternalNotificationErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Not Found
     */
    404: NotificationNotFoundError;
};

export type DeleteInternalNotificationError = DeleteInternalNotificationErrors[keyof DeleteInternalNotificationErrors];

export type DeleteInternalNotificationResponses = {
    /**
     * No Content
     */
    204: void;
};

export type DeleteInternalNotificationResponse = DeleteInternalNotificationResponses[keyof DeleteInternalNotificationResponses];

export type GetThreadSubscriptionStatusData = {
    body?: never;
    path: {
        threadId: ThreadId;
    };
    query?: never;
    url: '/api/thread/{threadId}/subscriptions/status';
};

export type GetThreadSubscriptionStatusErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
};

export type GetThreadSubscriptionStatusResponses = {
    /**
     * OK
     */
    200: GetThreadSubscriptionStatusQueryResult;
};

export type GetThreadSubscriptionStatusResponse = GetThreadSubscriptionStatusResponses[keyof GetThreadSubscriptionStatusResponses];

export type DeleteThreadSubscriptionData = {
    body?: never;
    path: {
        threadId: ThreadId;
    };
    query?: never;
    url: '/api/thread/{threadId}/subscriptions';
};

export type DeleteThreadSubscriptionErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Not Found
     */
    404: ThreadSubscriptionNotFoundError;
};

export type DeleteThreadSubscriptionError = DeleteThreadSubscriptionErrors[keyof DeleteThreadSubscriptionErrors];

export type DeleteThreadSubscriptionResponses = {
    /**
     * No Content
     */
    204: void;
};

export type DeleteThreadSubscriptionResponse = DeleteThreadSubscriptionResponses[keyof DeleteThreadSubscriptionResponses];

export type CreateThreadSubscriptionData = {
    body: CreateThreadSubscriptionRequestBody;
    path: {
        threadId: ThreadId;
    };
    query?: never;
    url: '/api/thread/{threadId}/subscriptions';
};

export type CreateThreadSubscriptionErrors = {
    /**
     * Unauthorized
     */
    401: unknown;
    /**
     * Forbidden
     */
    403: unknown;
    /**
     * Conflict
     */
    409: DuplicateThreadSubscriptionError;
};

export type CreateThreadSubscriptionError = CreateThreadSubscriptionErrors[keyof CreateThreadSubscriptionErrors];

export type CreateThreadSubscriptionResponses = {
    /**
     * No Content
     */
    204: void;
};

export type CreateThreadSubscriptionResponse = CreateThreadSubscriptionResponses[keyof CreateThreadSubscriptionResponses];

export type GetUsersData = {
    body?: never;
    path?: never;
    query?: {
        offset?: number;
        limit?: number;
    };
    url: '/api/users';
};

export type GetUsersErrors = {
    /**
     * Bad Request
     */
    400: string;
};

export type GetUsersError = GetUsersErrors[keyof GetUsersErrors];

export type GetUsersResponses = {
    /**
     * OK
     */
    200: Array<UserDto>;
};

export type GetUsersResponse = GetUsersResponses[keyof GetUsersResponses];

export type GetUserByIdData = {
    body?: never;
    path: {
        userId: UserId;
    };
    query?: never;
    url: '/api/users/{userId}';
};

export type GetUserByIdErrors = {
    /**
     * Not Found
     */
    404: UserNotFoundError;
};

export type GetUserByIdError = GetUserByIdErrors[keyof GetUserByIdErrors];

export type GetUserByIdResponses = {
    /**
     * OK
     */
    200: UserDto;
};

export type GetUserByIdResponse = GetUserByIdResponses[keyof GetUserByIdResponses];

export type GetUsersBulkData = {
    body?: never;
    path: {
        userIds: Array<UserId>;
    };
    query?: never;
    url: '/api/users/batch/{userIds}';
};

export type GetUsersBulkResponses = {
    /**
     * OK
     */
    200: Array<UserDto>;
};

export type GetUsersBulkResponse = GetUsersBulkResponses[keyof GetUsersBulkResponses];

export type ClientOptions = {
    baseUrl: 'http://localhost:8000' | (string & {});
};