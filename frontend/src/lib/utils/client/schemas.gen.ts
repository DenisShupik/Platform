// This file is auto-generated by @hey-api/openapi-ts

export const CategoryDtoSchema = {
    required: ['categoryId', 'createdAt', 'createdBy', 'forumId', 'title'],
    type: 'object',
    properties: {
        categoryId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/CategoryId'
                }
            ]
        },
        forumId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ForumId'
                }
            ]
        },
        title: {
            allOf: [
                {
                    '$ref': '#/components/schemas/CategoryTitle'
                }
            ]
        },
        createdBy: {
            allOf: [
                {
                    '$ref': '#/components/schemas/UserId'
                }
            ]
        },
        createdAt: {
            type: 'string',
            format: 'date-time'
        }
    },
    additionalProperties: false
} as const;

export const CategoryIdSchema = {
    pattern: '^(?!00000000-0000-0000-0000-000000000000$)',
    type: 'string',
    additionalProperties: false,
    format: 'uuid'
} as const;

export const CategoryNotFoundErrorSchema = {
    required: ['$type', 'categoryId'],
    type: 'object',
    properties: {
        '$type': {
            type: 'string',
            readOnly: true
        },
        categoryId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/CategoryId'
                }
            ]
        }
    },
    additionalProperties: false
} as const;

export const CategoryTitleSchema = {
    maxLength: 128,
    minLength: 3,
    pattern: '^(?!\\s*$).+',
    type: 'string',
    additionalProperties: false
} as const;

export const ChannelTypeSchema = {
    enum: [0, 1],
    type: 'integer',
    description: `Типы каналов доставки уведомлений

0 = Internal (Внутренний канал)

1 = Email (Электронная почта)`,
    format: 'int32',
    'x-enum-varnames': ['Internal', 'Email'],
    'x-enum-descriptions': ['Внутренний канал', 'Электронная почта']
} as const;

export const CreateCategoryRequestBodySchema = {
    required: ['forumId', 'title'],
    type: 'object',
    properties: {
        forumId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ForumId'
                }
            ]
        },
        title: {
            allOf: [
                {
                    '$ref': '#/components/schemas/CategoryTitle'
                }
            ]
        }
    },
    additionalProperties: false
} as const;

export const CreateForumRequestBodySchema = {
    required: ['title'],
    type: 'object',
    properties: {
        title: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ForumTitle'
                }
            ]
        }
    },
    additionalProperties: false
} as const;

export const CreatePostRequestBodySchema = {
    required: ['content'],
    type: 'object',
    properties: {
        content: {
            allOf: [
                {
                    '$ref': '#/components/schemas/PostContent'
                }
            ]
        }
    },
    additionalProperties: false
} as const;

export const CreateThreadRequestBodySchema = {
    required: ['categoryId', 'title'],
    type: 'object',
    properties: {
        categoryId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/CategoryId'
                }
            ]
        },
        title: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ThreadTitle'
                }
            ]
        }
    },
    additionalProperties: false
} as const;

export const CreateThreadSubscriptionRequestBodySchema = {
    required: ['channels'],
    type: 'object',
    properties: {
        channels: {
            uniqueItems: true,
            type: 'array',
            items: {
                '$ref': '#/components/schemas/ChannelType'
            },
            description: 'Каналы, по которым пользователь подписан на уведомления по данной теме'
        }
    },
    additionalProperties: false
} as const;

export const DuplicateThreadSubscriptionErrorSchema = {
    required: ['$type', 'threadId', 'userId'],
    type: 'object',
    properties: {
        '$type': {
            type: 'string',
            readOnly: true
        },
        userId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/UserId'
                }
            ]
        },
        threadId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ThreadId'
                }
            ]
        }
    },
    additionalProperties: false
} as const;

export const ForumContainsFilterSchema = {
    enum: [0, 1, 2],
    type: 'integer',
    description: `

0 = Category (Форум содержит разделы)

1 = Thread (Форум содержит темы)

2 = Post (Форум содержит сообщения)`,
    format: 'int32',
    'x-enum-varnames': ['Category', 'Thread', 'Post'],
    'x-enum-descriptions': ['Форум содержит разделы', 'Форум содержит темы', 'Форум содержит сообщения']
} as const;

export const ForumDtoSchema = {
    required: ['createdAt', 'createdBy', 'forumId', 'title'],
    type: 'object',
    properties: {
        forumId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ForumId'
                }
            ]
        },
        title: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ForumTitle'
                }
            ]
        },
        createdBy: {
            allOf: [
                {
                    '$ref': '#/components/schemas/UserId'
                }
            ]
        },
        createdAt: {
            type: 'string',
            format: 'date-time'
        }
    },
    additionalProperties: false
} as const;

export const ForumIdSchema = {
    pattern: '^(?!00000000-0000-0000-0000-000000000000$)',
    type: 'string',
    additionalProperties: false,
    format: 'uuid'
} as const;

export const ForumNotFoundErrorSchema = {
    required: ['$type', 'forumId'],
    type: 'object',
    properties: {
        '$type': {
            type: 'string',
            readOnly: true
        },
        forumId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ForumId'
                }
            ]
        }
    },
    additionalProperties: false
} as const;

export const ForumTitleSchema = {
    maxLength: 64,
    minLength: 3,
    pattern: '^(?!\\s*$).+',
    type: 'string',
    additionalProperties: false
} as const;

export const GetCategoryThreadsQuerySortEnumSchema = {
    enum: ['activity', '-activity'],
    type: 'string',
    description: `

activity (Sort by Activity ascending)

-activity (Sort by Activity descending)`,
    'x-enum-varnames': ['ActivityAsc', 'ActivityDesc'],
    'x-enum-descriptions': ['Sort by Activity ascending', 'Sort by Activity descending']
} as const;

export const GetCategoryThreadsQuerySortTypeSchema = {
    enum: [0],
    type: 'integer',
    description: `

0 = Activity`,
    format: 'int32',
    'x-enum-varnames': ['Activity'],
    'x-enum-descriptions': ['']
} as const;

export const GetForumsQuerySortEnumSchema = {
    enum: ['latestpost', '-latestpost'],
    type: 'string',
    description: `

latestpost (Sort by LatestPost ascending)

-latestpost (Sort by LatestPost descending)`,
    'x-enum-varnames': ['LatestPostAsc', 'LatestPostDesc'],
    'x-enum-descriptions': ['Sort by LatestPost ascending', 'Sort by LatestPost descending']
} as const;

export const GetForumsQuerySortTypeSchema = {
    enum: [0],
    type: 'integer',
    description: `

0 = LatestPost`,
    format: 'int32',
    'x-enum-varnames': ['LatestPost'],
    'x-enum-descriptions': ['']
} as const;

export const GetInternalNotificationQuerySortEnumSchema = {
    enum: ['occurredat', 'deliveredat', '-occurredat', '-deliveredat'],
    type: 'string',
    description: `

occurredat (Sort by OccurredAt ascending)

deliveredat (Sort by DeliveredAt ascending)

-occurredat (Sort by OccurredAt descending)

-deliveredat (Sort by DeliveredAt descending)`,
    'x-enum-varnames': ['OccurredAtAsc', 'DeliveredAtAsc', 'OccurredAtDesc', 'DeliveredAtDesc'],
    'x-enum-descriptions': ['Sort by OccurredAt ascending', 'Sort by DeliveredAt ascending', 'Sort by OccurredAt descending', 'Sort by DeliveredAt descending']
} as const;

export const GetInternalNotificationQuerySortTypeSchema = {
    enum: [0, 1],
    type: 'integer',
    description: `

0 = OccurredAt

1 = DeliveredAt`,
    format: 'int32',
    'x-enum-varnames': ['OccurredAt', 'DeliveredAt'],
    'x-enum-descriptions': ['', '']
} as const;

export const GetThreadSubscriptionStatusQueryResultSchema = {
    required: ['isSubscribed'],
    type: 'object',
    properties: {
        isSubscribed: {
            type: 'boolean',
            description: 'Подписан ли пользователь на тему'
        }
    },
    additionalProperties: false
} as const;

export const InternalNotificationDtoSchema = {
    required: ['notifiableEventId', 'occurredAt', 'payload'],
    type: 'object',
    properties: {
        payload: {
            oneOf: [
                {
                    '$ref': '#/components/schemas/PostAddedNotifiableEventPayload'
                },
                {
                    '$ref': '#/components/schemas/PostUpdatedNotifiableEventPayload'
                }
            ]
        },
        occurredAt: {
            type: 'string',
            format: 'date-time'
        },
        notifiableEventId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/NotifiableEventId'
                }
            ]
        },
        deliveredAt: {
            type: 'string',
            format: 'date-time',
            nullable: true
        }
    },
    additionalProperties: false
} as const;

export const InternalNotificationsPagedDtoSchema = {
    required: ['notifications', 'threads', 'totalCount', 'users'],
    type: 'object',
    properties: {
        notifications: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/InternalNotificationDto'
            }
        },
        threads: {
            type: 'object',
            additionalProperties: {
                '$ref': '#/components/schemas/ThreadTitle'
            }
        },
        users: {
            type: 'object',
            additionalProperties: {
                '$ref': '#/components/schemas/Username'
            }
        },
        totalCount: {
            type: 'integer',
            description: 'Общее количество уведомлений с учетом фильтрации',
            format: 'int64'
        }
    },
    additionalProperties: false
} as const;

export const NonPostAuthorErrorSchema = {
    required: ['$type', 'postId', 'threadId'],
    type: 'object',
    properties: {
        '$type': {
            type: 'string',
            readOnly: true
        },
        threadId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ThreadId'
                }
            ]
        },
        postId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/PostId'
                }
            ]
        }
    },
    additionalProperties: false
} as const;

export const NonThreadOwnerErrorSchema = {
    required: ['$type', 'threadId'],
    type: 'object',
    properties: {
        '$type': {
            type: 'string',
            readOnly: true
        },
        threadId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ThreadId'
                }
            ]
        }
    },
    additionalProperties: false
} as const;

export const NotOwnerErrorSchema = {
    required: ['$type'],
    type: 'object',
    properties: {
        '$type': {
            type: 'string',
            readOnly: true
        }
    },
    additionalProperties: false
} as const;

export const NotifiableEventIdSchema = {
    pattern: '^(?!00000000-0000-0000-0000-000000000000$)',
    type: 'string',
    additionalProperties: false,
    format: 'uuid'
} as const;

export const NotifiableEventPayloadSchema = {
    required: ['$type'],
    type: 'object',
    properties: {
        '$type': {
            type: 'string'
        }
    },
    additionalProperties: false,
    discriminator: {
        propertyName: '$type'
    }
} as const;

export const NotificationNotFoundErrorSchema = {
    required: ['$type', 'channel', 'notifiableEventId', 'userId'],
    type: 'object',
    properties: {
        '$type': {
            type: 'string',
            readOnly: true
        },
        userId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/UserId'
                }
            ]
        },
        notifiableEventId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/NotifiableEventId'
                }
            ]
        },
        channel: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ChannelType'
                }
            ],
            description: `Типы каналов доставки уведомлений

0 = Internal (Внутренний канал)

1 = Email (Электронная почта)`,
            'x-enum-varnames': ['Internal', 'Email'],
            'x-enum-descriptions': ['Внутренний канал', 'Электронная почта']
        }
    },
    additionalProperties: false
} as const;

export const PostAddedNotifiableEventPayloadSchema = {
    required: ['createdBy', 'postId', 'threadId'],
    type: 'object',
    allOf: [
        {
            '$ref': '#/components/schemas/NotifiableEventPayload'
        }
    ],
    properties: {
        threadId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ThreadId'
                }
            ]
        },
        postId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/PostId'
                }
            ]
        },
        createdBy: {
            allOf: [
                {
                    '$ref': '#/components/schemas/UserId'
                }
            ]
        }
    },
    additionalProperties: false
} as const;

export const PostContentSchema = {
    maxLength: 1024,
    minLength: 2,
    pattern: '^(?!\\s*$).+',
    type: 'string',
    additionalProperties: false
} as const;

export const PostDtoSchema = {
    required: ['content', 'createdAt', 'createdBy', 'postId', 'rowVersion', 'threadId', 'updatedAt', 'updatedBy'],
    type: 'object',
    properties: {
        threadId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ThreadId'
                }
            ]
        },
        postId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/PostId'
                }
            ]
        },
        content: {
            allOf: [
                {
                    '$ref': '#/components/schemas/PostContent'
                }
            ]
        },
        createdBy: {
            allOf: [
                {
                    '$ref': '#/components/schemas/UserId'
                }
            ]
        },
        createdAt: {
            type: 'string',
            format: 'date-time'
        },
        updatedBy: {
            allOf: [
                {
                    '$ref': '#/components/schemas/UserId'
                }
            ]
        },
        updatedAt: {
            type: 'string',
            format: 'date-time'
        },
        rowVersion: {
            type: 'integer',
            format: 'int32'
        }
    },
    additionalProperties: false
} as const;

export const PostIdSchema = {
    minimum: 1,
    type: 'integer',
    additionalProperties: false,
    format: 'int64'
} as const;

export const PostNotFoundErrorSchema = {
    required: ['$type', 'postId', 'threadId'],
    type: 'object',
    properties: {
        '$type': {
            type: 'string',
            readOnly: true
        },
        threadId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ThreadId'
                }
            ]
        },
        postId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/PostId'
                }
            ]
        }
    },
    additionalProperties: false
} as const;

export const PostStaleErrorSchema = {
    required: ['$type', 'postId', 'rowVersion', 'threadId'],
    type: 'object',
    properties: {
        '$type': {
            type: 'string',
            readOnly: true
        },
        threadId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ThreadId'
                }
            ]
        },
        postId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/PostId'
                }
            ]
        },
        rowVersion: {
            type: 'integer',
            format: 'int32'
        }
    },
    additionalProperties: false
} as const;

export const PostUpdatedNotifiableEventPayloadSchema = {
    required: ['postId', 'threadId', 'updatedBy'],
    type: 'object',
    allOf: [
        {
            '$ref': '#/components/schemas/NotifiableEventPayload'
        }
    ],
    properties: {
        threadId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ThreadId'
                }
            ]
        },
        postId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/PostId'
                }
            ]
        },
        updatedBy: {
            allOf: [
                {
                    '$ref': '#/components/schemas/UserId'
                }
            ]
        }
    },
    additionalProperties: false
} as const;

export const SortOrderTypeSchema = {
    enum: [0, 1],
    type: 'integer',
    description: `

0 = Ascending

1 = Descending`,
    format: 'int32',
    'x-enum-varnames': ['Ascending', 'Descending'],
    'x-enum-descriptions': ['', '']
} as const;

export const ThreadDtoSchema = {
    required: ['categoryId', 'createdAt', 'createdBy', 'nextPostId', 'status', 'threadId', 'title'],
    type: 'object',
    properties: {
        threadId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ThreadId'
                }
            ]
        },
        categoryId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/CategoryId'
                }
            ]
        },
        title: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ThreadTitle'
                }
            ]
        },
        createdBy: {
            allOf: [
                {
                    '$ref': '#/components/schemas/UserId'
                }
            ]
        },
        createdAt: {
            type: 'string',
            format: 'date-time'
        },
        nextPostId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/PostId'
                }
            ]
        },
        status: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ThreadStatus'
                }
            ],
            description: `Состояние темы

0 = Draft (Тема еще подготавливается автором)

1 = Published (Тема опубликована и доступна пользователям)`,
            'x-enum-varnames': ['Draft', 'Published'],
            'x-enum-descriptions': ['Тема еще подготавливается автором', 'Тема опубликована и доступна пользователям']
        }
    },
    additionalProperties: false
} as const;

export const ThreadIdSchema = {
    pattern: '^(?!00000000-0000-0000-0000-000000000000$)',
    type: 'string',
    additionalProperties: false,
    format: 'uuid'
} as const;

export const ThreadNotFoundErrorSchema = {
    required: ['$type', 'threadId'],
    type: 'object',
    properties: {
        '$type': {
            type: 'string',
            readOnly: true
        },
        threadId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ThreadId'
                }
            ]
        }
    },
    additionalProperties: false
} as const;

export const ThreadStatusSchema = {
    enum: [0, 1],
    type: 'integer',
    description: `Состояние темы

0 = Draft (Тема еще подготавливается автором)

1 = Published (Тема опубликована и доступна пользователям)`,
    format: 'int32',
    'x-enum-varnames': ['Draft', 'Published'],
    'x-enum-descriptions': ['Тема еще подготавливается автором', 'Тема опубликована и доступна пользователям']
} as const;

export const ThreadSubscriptionNotFoundErrorSchema = {
    required: ['$type', 'threadId', 'userId'],
    type: 'object',
    properties: {
        '$type': {
            type: 'string',
            readOnly: true
        },
        userId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/UserId'
                }
            ]
        },
        threadId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ThreadId'
                }
            ]
        }
    },
    additionalProperties: false
} as const;

export const ThreadTitleSchema = {
    maxLength: 128,
    minLength: 3,
    pattern: '^(?!\\s*$).+',
    type: 'string',
    additionalProperties: false
} as const;

export const UpdatePostRequestBodySchema = {
    required: ['content', 'rowVersion'],
    type: 'object',
    properties: {
        content: {
            allOf: [
                {
                    '$ref': '#/components/schemas/PostContent'
                }
            ]
        },
        rowVersion: {
            type: 'integer',
            format: 'int32'
        }
    },
    additionalProperties: false
} as const;

export const UserDtoSchema = {
    required: ['createdAt', 'email', 'enabled', 'userId', 'username'],
    type: 'object',
    properties: {
        userId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/UserId'
                }
            ]
        },
        username: {
            allOf: [
                {
                    '$ref': '#/components/schemas/Username'
                }
            ]
        },
        email: {
            type: 'string'
        },
        enabled: {
            type: 'boolean'
        },
        createdAt: {
            type: 'string',
            format: 'date-time'
        }
    },
    additionalProperties: false
} as const;

export const UserIdSchema = {
    pattern: '^(?!00000000-0000-0000-0000-000000000000$)',
    type: 'string',
    additionalProperties: false,
    format: 'uuid'
} as const;

export const UserNotFoundErrorSchema = {
    required: ['$type', 'userId'],
    type: 'object',
    properties: {
        '$type': {
            type: 'string',
            readOnly: true
        },
        userId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/UserId'
                }
            ]
        }
    },
    additionalProperties: false
} as const;

export const UsernameSchema = {
    maxLength: 64,
    minLength: 3,
    pattern: '^[a-z0-9]+(_[a-z0-9]+)*$',
    type: 'string',
    additionalProperties: false
} as const;