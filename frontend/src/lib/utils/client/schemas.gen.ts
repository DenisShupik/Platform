// This file is auto-generated by @hey-api/openapi-ts

export const ActivityDtoSchema = {
    required: ['$type', 'occurredAt', 'occurredBy'],
    type: 'object',
    properties: {
        '$type': {
            type: 'string'
        },
        occurredBy: {
            allOf: [
                {
                    '$ref': '#/components/schemas/UserId'
                }
            ]
        },
        occurredAt: {
            type: 'string',
            format: 'date-time'
        }
    },
    additionalProperties: false,
    discriminator: {
        propertyName: '$type'
    }
} as const;

export const ActivityTypeSchema = {
    enum: [0],
    type: 'integer',
    description: `

0 = PostAdded`,
    format: 'int32',
    'x-enum-varnames': ['PostAdded'],
    'x-enum-descriptions': ['']
} as const;

export const CategoryDtoSchema = {
    required: ['categoryId', 'createdAt', 'createdBy', 'forumId', 'title'],
    type: 'object',
    properties: {
        categoryId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/CategoryId'
                }
            ]
        },
        forumId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ForumId'
                }
            ]
        },
        title: {
            allOf: [
                {
                    '$ref': '#/components/schemas/CategoryTitle'
                }
            ]
        },
        createdBy: {
            allOf: [
                {
                    '$ref': '#/components/schemas/UserId'
                }
            ]
        },
        createdAt: {
            type: 'string',
            format: 'date-time'
        }
    },
    additionalProperties: false
} as const;

export const CategoryIdSchema = {
    pattern: '^(?!00000000-0000-0000-0000-000000000000$)',
    type: 'string',
    additionalProperties: false,
    format: 'uuid'
} as const;

export const CategoryNotFoundErrorSchema = {
    required: ['$type', 'categoryId'],
    type: 'object',
    properties: {
        '$type': {
            type: 'string',
            readOnly: true
        },
        categoryId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/CategoryId'
                }
            ]
        }
    },
    additionalProperties: false
} as const;

export const CategoryTitleSchema = {
    maxLength: 128,
    minLength: 3,
    pattern: '^(?!\\s*$).+',
    type: 'string',
    additionalProperties: false
} as const;

export const ChannelTypeSchema = {
    enum: [0, 1],
    type: 'integer',
    description: `Типы каналов доставки уведомлений

0 = Internal (Внутренний канал)

1 = Email (Электронная почта)`,
    format: 'int32',
    'x-enum-varnames': ['Internal', 'Email'],
    'x-enum-descriptions': ['Внутренний канал', 'Электронная почта']
} as const;

export const CreateCategoryRequestBodySchema = {
    required: ['forumId', 'title'],
    type: 'object',
    properties: {
        forumId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ForumId'
                }
            ]
        },
        title: {
            allOf: [
                {
                    '$ref': '#/components/schemas/CategoryTitle'
                }
            ]
        }
    },
    additionalProperties: false
} as const;

export const CreateForumRequestBodySchema = {
    required: ['title'],
    type: 'object',
    properties: {
        title: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ForumTitle'
                }
            ]
        }
    },
    additionalProperties: false
} as const;

export const CreatePostRequestBodySchema = {
    required: ['content'],
    type: 'object',
    properties: {
        content: {
            allOf: [
                {
                    '$ref': '#/components/schemas/PostContent'
                }
            ]
        }
    },
    additionalProperties: false
} as const;

export const CreateThreadRequestBodySchema = {
    required: ['categoryId', 'title'],
    type: 'object',
    properties: {
        categoryId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/CategoryId'
                }
            ]
        },
        title: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ThreadTitle'
                }
            ]
        }
    },
    additionalProperties: false
} as const;

export const CreateThreadSubscriptionRequestBodySchema = {
    required: ['channels'],
    type: 'object',
    properties: {
        channels: {
            uniqueItems: true,
            type: 'array',
            items: {
                '$ref': '#/components/schemas/ChannelType'
            },
            description: 'Каналы, по которым пользователь подписан на уведомления по данной теме'
        }
    },
    additionalProperties: false
} as const;

export const DuplicateThreadSubscriptionErrorSchema = {
    required: ['$type', 'threadId', 'userId'],
    type: 'object',
    properties: {
        '$type': {
            type: 'string',
            readOnly: true
        },
        userId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/UserId'
                }
            ]
        },
        threadId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ThreadId'
                }
            ]
        }
    },
    additionalProperties: false
} as const;

export const ForumDtoSchema = {
    required: ['createdAt', 'createdBy', 'forumId', 'title'],
    type: 'object',
    properties: {
        forumId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ForumId'
                }
            ]
        },
        title: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ForumTitle'
                }
            ]
        },
        createdBy: {
            allOf: [
                {
                    '$ref': '#/components/schemas/UserId'
                }
            ]
        },
        createdAt: {
            type: 'string',
            format: 'date-time'
        }
    },
    additionalProperties: false
} as const;

export const ForumIdSchema = {
    pattern: '^(?!00000000-0000-0000-0000-000000000000$)',
    type: 'string',
    additionalProperties: false,
    format: 'uuid'
} as const;

export const ForumNotFoundErrorSchema = {
    required: ['$type', 'forumId'],
    type: 'object',
    properties: {
        '$type': {
            type: 'string',
            readOnly: true
        },
        forumId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ForumId'
                }
            ]
        }
    },
    additionalProperties: false
} as const;

export const ForumTitleSchema = {
    maxLength: 64,
    minLength: 3,
    pattern: '^(?!\\s*$).+',
    type: 'string',
    additionalProperties: false
} as const;

export const GetActivitiesPagedQueryGroupByTypeSchema = {
    enum: [0, 1, 2],
    type: 'integer',
    description: `

0 = Forum

1 = Category

2 = Thread`,
    format: 'int32',
    'x-enum-varnames': ['Forum', 'Category', 'Thread'],
    'x-enum-descriptions': ['', '', '']
} as const;

export const GetActivitiesPagedQueryModeTypeSchema = {
    enum: [0],
    type: 'integer',
    description: `

0 = Latest`,
    format: 'int32',
    'x-enum-varnames': ['Latest'],
    'x-enum-descriptions': ['']
} as const;

export const GetActivitiesPagedQuerySortEnumSchema = {
    enum: ['latest', '-latest'],
    type: 'string',
    description: `

latest (Sort by Latest ascending)

-latest (Sort by Latest descending)`,
    'x-enum-varnames': ['LatestAsc', 'LatestDesc'],
    'x-enum-descriptions': ['Sort by Latest ascending', 'Sort by Latest descending']
} as const;

export const GetCategoriesPagedQuerySortEnumSchema = {
    enum: ['categoryid', 'forumid', '-categoryid', '-forumid'],
    type: 'string',
    description: `

categoryid (Sort by CategoryId ascending)

forumid (Sort by ForumId ascending)

-categoryid (Sort by CategoryId descending)

-forumid (Sort by ForumId descending)`,
    'x-enum-varnames': ['CategoryIdAsc', 'ForumIdAsc', 'CategoryIdDesc', 'ForumIdDesc'],
    'x-enum-descriptions': ['Sort by CategoryId ascending', 'Sort by ForumId ascending', 'Sort by CategoryId descending', 'Sort by ForumId descending']
} as const;

export const GetCategoryThreadsQuerySortEnumSchema = {
    enum: ['activity', '-activity'],
    type: 'string',
    description: `

activity (Sort by Activity ascending)

-activity (Sort by Activity descending)`,
    'x-enum-varnames': ['ActivityAsc', 'ActivityDesc'],
    'x-enum-descriptions': ['Sort by Activity ascending', 'Sort by Activity descending']
} as const;

export const GetForumsPagedQuerySortEnumSchema = {
    enum: ['forumid', '-forumid'],
    type: 'string',
    description: `

forumid (Sort by ForumId ascending)

-forumid (Sort by ForumId descending)`,
    'x-enum-varnames': ['ForumIdAsc', 'ForumIdDesc'],
    'x-enum-descriptions': ['Sort by ForumId ascending', 'Sort by ForumId descending']
} as const;

export const GetInternalNotificationQuerySortEnumSchema = {
    enum: ['occurredat', 'deliveredat', '-occurredat', '-deliveredat'],
    type: 'string',
    description: `

occurredat (Sort by OccurredAt ascending)

deliveredat (Sort by DeliveredAt ascending)

-occurredat (Sort by OccurredAt descending)

-deliveredat (Sort by DeliveredAt descending)`,
    'x-enum-varnames': ['OccurredAtAsc', 'DeliveredAtAsc', 'OccurredAtDesc', 'DeliveredAtDesc'],
    'x-enum-descriptions': ['Sort by OccurredAt ascending', 'Sort by DeliveredAt ascending', 'Sort by OccurredAt descending', 'Sort by DeliveredAt descending']
} as const;

export const GetInternalNotificationQuerySortTypeSchema = {
    enum: [0, 1],
    type: 'integer',
    description: `

0 = OccurredAt

1 = DeliveredAt`,
    format: 'int32',
    'x-enum-varnames': ['OccurredAt', 'DeliveredAt'],
    'x-enum-descriptions': ['', '']
} as const;

export const GetThreadPostsPagedQuerySortEnumSchema = {
    enum: ['index', '-index'],
    type: 'string',
    description: `

index (Sort by Index ascending)

-index (Sort by Index descending)`,
    'x-enum-varnames': ['IndexAsc', 'IndexDesc'],
    'x-enum-descriptions': ['Sort by Index ascending', 'Sort by Index descending']
} as const;

export const GetThreadSubscriptionStatusQueryResultSchema = {
    required: ['isSubscribed'],
    type: 'object',
    properties: {
        isSubscribed: {
            type: 'boolean',
            description: 'Подписан ли пользователь на тему'
        }
    },
    additionalProperties: false
} as const;

export const GetThreadsPagedQuerySortEnumSchema = {
    enum: ['threadid', '-threadid'],
    type: 'string',
    description: `

threadid (Sort by ThreadId ascending)

-threadid (Sort by ThreadId descending)`,
    'x-enum-varnames': ['ThreadIdAsc', 'ThreadIdDesc'],
    'x-enum-descriptions': ['Sort by ThreadId ascending', 'Sort by ThreadId descending']
} as const;

export const GetUsersPagedQuerySortEnumSchema = {
    enum: ['userid', '-userid'],
    type: 'string',
    description: `

userid (Sort by UserId ascending)

-userid (Sort by UserId descending)`,
    'x-enum-varnames': ['UserIdAsc', 'UserIdDesc'],
    'x-enum-descriptions': ['Sort by UserId ascending', 'Sort by UserId descending']
} as const;

export const InternalNotificationDtoSchema = {
    required: ['notifiableEventId', 'occurredAt', 'payload'],
    type: 'object',
    properties: {
        payload: {
            oneOf: [
                {
                    '$ref': '#/components/schemas/PostAddedNotifiableEventPayload'
                },
                {
                    '$ref': '#/components/schemas/PostUpdatedNotifiableEventPayload'
                }
            ]
        },
        occurredAt: {
            type: 'string',
            format: 'date-time'
        },
        notifiableEventId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/NotifiableEventId'
                }
            ]
        },
        deliveredAt: {
            type: 'string',
            format: 'date-time',
            nullable: true
        }
    },
    additionalProperties: false
} as const;

export const InternalNotificationsPagedDtoSchema = {
    required: ['notifications', 'threads', 'totalCount', 'users'],
    type: 'object',
    properties: {
        notifications: {
            type: 'array',
            items: {
                '$ref': '#/components/schemas/InternalNotificationDto'
            }
        },
        threads: {
            type: 'object',
            additionalProperties: {
                '$ref': '#/components/schemas/ThreadTitle'
            }
        },
        users: {
            type: 'object',
            additionalProperties: {
                '$ref': '#/components/schemas/Username'
            }
        },
        totalCount: {
            type: 'integer',
            description: 'Общее количество уведомлений с учетом фильтрации',
            format: 'int64'
        }
    },
    additionalProperties: false
} as const;

export const NonPostAuthorErrorSchema = {
    required: ['$type', 'postId', 'threadId'],
    type: 'object',
    properties: {
        '$type': {
            type: 'string',
            readOnly: true
        },
        threadId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ThreadId'
                }
            ]
        },
        postId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/PostId'
                }
            ]
        }
    },
    additionalProperties: false
} as const;

export const NonThreadOwnerErrorSchema = {
    required: ['$type', 'threadId'],
    type: 'object',
    properties: {
        '$type': {
            type: 'string',
            readOnly: true
        },
        threadId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ThreadId'
                }
            ]
        }
    },
    additionalProperties: false
} as const;

export const NotOwnerErrorSchema = {
    required: ['$type'],
    type: 'object',
    properties: {
        '$type': {
            type: 'string',
            readOnly: true
        }
    },
    additionalProperties: false
} as const;

export const NotifiableEventIdSchema = {
    pattern: '^(?!00000000-0000-0000-0000-000000000000$)',
    type: 'string',
    additionalProperties: false,
    format: 'uuid'
} as const;

export const NotifiableEventPayloadSchema = {
    required: ['$type'],
    type: 'object',
    properties: {
        '$type': {
            type: 'string'
        }
    },
    additionalProperties: false,
    discriminator: {
        propertyName: '$type',
        mapping: {
            PostAdded: '#/components/schemas/PostAddedNotifiableEventPayload',
            PostUpdated: '#/components/schemas/PostUpdatedNotifiableEventPayload'
        }
    }
} as const;

export const NotifiableEventPayloadTypeSchema = {
    enum: ['PostAdded', 'PostUpdated'],
    type: 'string',
    description: `Типы уведомлений

PostAdded

PostUpdated`,
    'x-enum-varnames': ['PostAdded', 'PostUpdated']
} as const;

export const NotificationNotFoundErrorSchema = {
    required: ['$type', 'channel', 'notifiableEventId', 'userId'],
    type: 'object',
    properties: {
        '$type': {
            type: 'string',
            readOnly: true
        },
        userId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/UserId'
                }
            ]
        },
        notifiableEventId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/NotifiableEventId'
                }
            ]
        },
        channel: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ChannelType'
                }
            ],
            description: `Типы каналов доставки уведомлений

0 = Internal (Внутренний канал)

1 = Email (Электронная почта)`,
            'x-enum-varnames': ['Internal', 'Email'],
            'x-enum-descriptions': ['Внутренний канал', 'Электронная почта']
        }
    },
    additionalProperties: false
} as const;

export const PaginationLimitMin10Max100Default100Schema = {
    maximum: 100,
    minimum: 10,
    type: 'integer',
    additionalProperties: false,
    default: 100
} as const;

export const PaginationOffsetSchema = {
    maximum: 2147483647,
    minimum: 0,
    type: 'integer',
    additionalProperties: false,
    default: 0
} as const;

export const PostAddedActivityDtoSchema = {
    required: ['categoryId', 'forumId', 'postId', 'threadId'],
    type: 'object',
    allOf: [
        {
            '$ref': '#/components/schemas/ActivityDto'
        }
    ],
    properties: {
        forumId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ForumId'
                }
            ]
        },
        categoryId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/CategoryId'
                }
            ]
        },
        threadId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ThreadId'
                }
            ]
        },
        postId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/PostId'
                }
            ]
        }
    },
    additionalProperties: false
} as const;

export const PostAddedNotifiableEventPayloadSchema = {
    required: ['createdBy', 'postId', 'threadId'],
    type: 'object',
    allOf: [
        {
            '$ref': '#/components/schemas/NotifiableEventPayload'
        }
    ],
    properties: {
        threadId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ThreadId'
                }
            ]
        },
        postId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/PostId'
                }
            ]
        },
        createdBy: {
            allOf: [
                {
                    '$ref': '#/components/schemas/UserId'
                }
            ]
        }
    },
    additionalProperties: false
} as const;

export const PostContentSchema = {
    maxLength: 1024,
    minLength: 2,
    pattern: '^(?!\\s*$).+',
    type: 'string',
    additionalProperties: false
} as const;

export const PostDtoSchema = {
    required: ['content', 'createdAt', 'createdBy', 'postId', 'rowVersion', 'threadId', 'updatedAt', 'updatedBy'],
    type: 'object',
    properties: {
        postId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/PostId'
                }
            ]
        },
        threadId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ThreadId'
                }
            ]
        },
        content: {
            allOf: [
                {
                    '$ref': '#/components/schemas/PostContent'
                }
            ]
        },
        createdBy: {
            allOf: [
                {
                    '$ref': '#/components/schemas/UserId'
                }
            ]
        },
        createdAt: {
            type: 'string',
            format: 'date-time'
        },
        updatedBy: {
            allOf: [
                {
                    '$ref': '#/components/schemas/UserId'
                }
            ]
        },
        updatedAt: {
            type: 'string',
            format: 'date-time'
        },
        rowVersion: {
            type: 'integer',
            format: 'int32'
        }
    },
    additionalProperties: false
} as const;

export const PostIdSchema = {
    pattern: '^(?!00000000-0000-0000-0000-000000000000$)',
    type: 'string',
    additionalProperties: false,
    format: 'uuid'
} as const;

export const PostIndexSchema = {
    maximum: 18446744073709552000,
    minimum: 0,
    type: 'integer',
    additionalProperties: false
} as const;

export const PostNotFoundErrorSchema = {
    required: ['$type', 'postId'],
    type: 'object',
    properties: {
        '$type': {
            type: 'string',
            readOnly: true
        },
        postId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/PostId'
                }
            ]
        }
    },
    additionalProperties: false
} as const;

export const PostStaleErrorSchema = {
    required: ['$type', 'postId', 'rowVersion', 'threadId'],
    type: 'object',
    properties: {
        '$type': {
            type: 'string',
            readOnly: true
        },
        threadId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ThreadId'
                }
            ]
        },
        postId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/PostId'
                }
            ]
        },
        rowVersion: {
            type: 'integer',
            format: 'int32'
        }
    },
    additionalProperties: false
} as const;

export const PostUpdatedNotifiableEventPayloadSchema = {
    required: ['postId', 'threadId', 'updatedBy'],
    type: 'object',
    allOf: [
        {
            '$ref': '#/components/schemas/NotifiableEventPayload'
        }
    ],
    properties: {
        threadId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ThreadId'
                }
            ]
        },
        postId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/PostId'
                }
            ]
        },
        updatedBy: {
            allOf: [
                {
                    '$ref': '#/components/schemas/UserId'
                }
            ]
        }
    },
    additionalProperties: false
} as const;

export const SortOrderTypeSchema = {
    enum: [0, 1],
    type: 'integer',
    description: `

0 = Ascending

1 = Descending`,
    format: 'int32',
    'x-enum-varnames': ['Ascending', 'Descending'],
    'x-enum-descriptions': ['', '']
} as const;

export const ThreadDtoSchema = {
    required: ['categoryId', 'createdAt', 'createdBy', 'status', 'threadId', 'title'],
    type: 'object',
    properties: {
        threadId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ThreadId'
                }
            ]
        },
        categoryId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/CategoryId'
                }
            ]
        },
        title: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ThreadTitle'
                }
            ]
        },
        createdBy: {
            allOf: [
                {
                    '$ref': '#/components/schemas/UserId'
                }
            ]
        },
        createdAt: {
            type: 'string',
            format: 'date-time'
        },
        status: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ThreadStatus'
                }
            ],
            description: `Состояние темы

0 = Draft (Тема еще подготавливается автором)

1 = Published (Тема опубликована и доступна пользователям)`,
            'x-enum-varnames': ['Draft', 'Published'],
            'x-enum-descriptions': ['Тема еще подготавливается автором', 'Тема опубликована и доступна пользователям']
        }
    },
    additionalProperties: false
} as const;

export const ThreadIdSchema = {
    pattern: '^(?!00000000-0000-0000-0000-000000000000$)',
    type: 'string',
    additionalProperties: false,
    format: 'uuid'
} as const;

export const ThreadNotFoundErrorSchema = {
    required: ['$type', 'threadId'],
    type: 'object',
    properties: {
        '$type': {
            type: 'string',
            readOnly: true
        },
        threadId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ThreadId'
                }
            ]
        }
    },
    additionalProperties: false
} as const;

export const ThreadStatusSchema = {
    enum: [0, 1],
    type: 'integer',
    description: `Состояние темы

0 = Draft (Тема еще подготавливается автором)

1 = Published (Тема опубликована и доступна пользователям)`,
    format: 'int32',
    'x-enum-varnames': ['Draft', 'Published'],
    'x-enum-descriptions': ['Тема еще подготавливается автором', 'Тема опубликована и доступна пользователям']
} as const;

export const ThreadSubscriptionNotFoundErrorSchema = {
    required: ['$type', 'threadId', 'userId'],
    type: 'object',
    properties: {
        '$type': {
            type: 'string',
            readOnly: true
        },
        userId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/UserId'
                }
            ]
        },
        threadId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/ThreadId'
                }
            ]
        }
    },
    additionalProperties: false
} as const;

export const ThreadTitleSchema = {
    maxLength: 128,
    minLength: 3,
    pattern: '^(?!\\s*$).+',
    type: 'string',
    additionalProperties: false
} as const;

export const UpdatePostRequestBodySchema = {
    required: ['content', 'rowVersion'],
    type: 'object',
    properties: {
        content: {
            allOf: [
                {
                    '$ref': '#/components/schemas/PostContent'
                }
            ]
        },
        rowVersion: {
            type: 'integer',
            format: 'int32'
        }
    },
    additionalProperties: false
} as const;

export const UserDtoSchema = {
    required: ['createdAt', 'email', 'enabled', 'userId', 'username'],
    type: 'object',
    properties: {
        userId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/UserId'
                }
            ]
        },
        username: {
            allOf: [
                {
                    '$ref': '#/components/schemas/Username'
                }
            ]
        },
        email: {
            type: 'string'
        },
        enabled: {
            type: 'boolean'
        },
        createdAt: {
            type: 'string',
            format: 'date-time'
        }
    },
    additionalProperties: false
} as const;

export const UserIdSchema = {
    pattern: '^(?!00000000-0000-0000-0000-000000000000$)',
    type: 'string',
    additionalProperties: false,
    format: 'uuid'
} as const;

export const UserNotFoundErrorSchema = {
    required: ['$type', 'userId'],
    type: 'object',
    properties: {
        '$type': {
            type: 'string',
            readOnly: true
        },
        userId: {
            allOf: [
                {
                    '$ref': '#/components/schemas/UserId'
                }
            ]
        }
    },
    additionalProperties: false
} as const;

export const UsernameSchema = {
    maxLength: 64,
    minLength: 3,
    pattern: '^[a-z0-9]+(_[a-z0-9]+)*$',
    type: 'string',
    additionalProperties: false
} as const;